<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Soccer Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            flex-direction: column;
        }

        .game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 80vh;
            width: 80vw;
        }

        #game-canvas {
            display: block;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            height: 100%;
            width: 100%;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            font-size: 1.5rem;
            text-align: center;
            pointer-events: none;
        }
        
        .ui-element {
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 8px;
        }

        #score-display {
            font-weight: bold;
        }
        
        #score-display .blue-score {
            color: #63b3ed;
        }

        #score-display .red-score {
            color: #e53e3e;
        }

        #timer-display {
            font-weight: bold;
            color: #f6ad55;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: #f6ad55;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            text-align: center;
            z-index: 10;
        }

        .instructions {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            text-align: center;
            font-size: 0.75rem;
            width: 100%;
            box-sizing: border-box;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .controls button {
            background-color: rgba(100, 100, 100, 0.5);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .controls button:hover {
            background-color: rgba(80, 80, 80, 0.7);
        }

        .power-meter {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 5px;
            background-color: #333;
            border: 1px solid #fff;
            border-radius: 2.5px;
            overflow: hidden;
            display: none;
        }

        .power-meter-fill {
            height: 100%;
            background: linear-gradient(to right, #22c55e, #fde047, #ef4444);
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui-overlay">
            <div id="score-element" class="ui-element">Score: <span id="score-display"></span></div>
            <div id="timer-element" class="ui-element">Time: <span id="timer-display">90</span>s</div>
        </div>
        <canvas id="game-canvas"></canvas>
        <div id="message"></div>
    </div>
    <div class="controls">
        <button id="startButton">Play</button>
        <button id="restartButton">Restart</button>
    </div>
    <div class="instructions">
        <h3>How to Play</h3>
        <p>Player 1 (Blue): Arrow Keys to move, L or K to shoot/tackle. Player 2 (Red): WASD to move, F or G to shoot/tackle.</p>
    </div>

    <script>
        // Game state and constants
        let blueScore = 0;
        let redScore = 0;
        let timeRemaining = 90;
        let isGameOver = false;
        let isGameStarted = false;
        let ballHolder = null;
        let isGoalScored = false;
        const FIELD_WIDTH = 60;
        const FIELD_LENGTH = 30;
        const PLAYER_SPEED = 0.2;
        const BALL_FRICTION = 0.96;
        const DRIBBLING_OFFSET = 1.5;
        const TACKLE_DISTANCE = 2.5;
        let timerInterval;
        let powerMeter1, powerMeter2;
        let shootingPower1 = 0;
        let shootingPower2 = 0;
        const MAX_POWER = 20;
        const POWER_CHARGE_RATE = 1;
        const JUMP_STRENGTH = 1.0;

        // Chip shot variables
        let p1ShootKeyDownTime = 0;
        let p2ShootKeyDownTime = 0;
        const TAP_DURATION = 200; // A tap is a press shorter than 200ms
        const CHIP_LIFT_STRENGTH = 1.5;
        const CHIP_FORWARD_STRENGTH = 0.5;

        // Three.js setup
        let scene, camera, renderer, player1, player2, ball, goalkeeper1, goalkeeper2;
        let pressedKeys = {};
        let player1Direction = new THREE.Vector3();
        let player2Direction = new THREE.Vector3();
        let lastPlayer1Direction = new THREE.Vector3();
        let lastPlayer2Direction = new THREE.Vector3();
        let goalkeeper1Direction = 1;
        let goalkeeper2Direction = 1;
        
        // Motion trail variables
        const trailVertices = [];
        const trailMaterial = new THREE.LineBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 0.5
        });
        const trailGeometry = new THREE.BufferGeometry();
        let trailLine;

        window.onload = function () {
            init();
            setupControls();
            animate();
            resizeCanvas();
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x317256);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 25);
            camera.lookAt(0, 0, 0);

            const canvas = document.getElementById('game-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);

            createField();

            player1 = createPlayer(0x63b3ed, 0xffe0bd);
            player1.position.set(20, 0.75, 0);
            player1.rotation.y = Math.PI / 2;
            lastPlayer1Direction.set(-1, 0, 0);
            scene.add(player1);

            player2 = createPlayer(0xe53e3e, 0xffe0bd);
            player2.position.set(-20, 0.75, 0);
            player2.rotation.y = -Math.PI / 2;
            lastPlayer2Direction.set(1, 0, 0);
            scene.add(player2);

            // Goalkeepers back to white
            goalkeeper1 = createPlayer(0xffffff, 0xffffff);
            goalkeeper1.position.set(FIELD_WIDTH / 2 - 1, 0.75, 0);
            scene.add(goalkeeper1);

            goalkeeper2 = createPlayer(0xffffff, 0xffffff);
            goalkeeper2.position.set(-FIELD_WIDTH / 2 + 1, 0.75, 0);
            scene.add(goalkeeper2);
            
            const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xe0e0e0 });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, 0.75, 0);
            ball.castShadow = true;
            scene.add(ball);
            ball.velocity = new THREE.Vector3(0, 0, 0);

            createGoal(-FIELD_WIDTH / 2, 'left');
            createGoal(FIELD_WIDTH / 2, 'right');

            powerMeter1 = document.createElement('div');
            powerMeter1.className = 'power-meter';
            powerMeter1.innerHTML = '<div class="power-meter-fill"></div>';
            document.querySelector('.game-container').appendChild(powerMeter1);

            powerMeter2 = document.createElement('div');
            powerMeter2.className = 'power-meter';
            powerMeter2.innerHTML = '<div class="power-meter-fill"></div>';
            document.querySelector('.game-container').appendChild(powerMeter2);

            trailLine = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trailLine);

            updateScoreDisplay();
        }

        function createPlayer(bodyColor, headColor) {
            const playerGroup = new THREE.Group();
            
            const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.7, 1.5, 32);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.0;
            body.castShadow = true;
            playerGroup.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.7, 32, 32);
            const headMaterial = new THREE.MeshLambertMaterial({ color: headColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.2;
            head.castShadow = true;
            playerGroup.add(head);

            playerGroup.castShadow = true;
            return playerGroup;
        }

        function createField() {
            const lightGreen = new THREE.Color(0x48bb78);
            const darkGreen = new THREE.Color(0x38a169);
            const stripeWidth = 5;
            const numStripes = FIELD_WIDTH / stripeWidth;

            for (let i = 0; i < numStripes; i++) {
                const stripeColor = i % 2 === 0 ? lightGreen : darkGreen;
                const stripeGeometry = new THREE.PlaneGeometry(stripeWidth, FIELD_LENGTH);
                const stripeMaterial = new THREE.MeshLambertMaterial({ color: stripeColor });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.rotation.x = -Math.PI / 2;
                stripe.position.x = (i - (numStripes / 2 - 0.5)) * stripeWidth;
                stripe.receiveShadow = true;
                scene.add(stripe);
            }

            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineThickness = 0.2;

            const centerCircleGeometry = new THREE.RingGeometry(5, 5 + lineThickness, 32);
            const centerCircleMesh = new THREE.Mesh(centerCircleGeometry, lineMaterial);
            centerCircleMesh.rotation.x = -Math.PI / 2;
            centerCircleMesh.position.y = 0.01;
            scene.add(centerCircleMesh);

            const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(lineThickness, FIELD_LENGTH), lineMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.01;
            scene.add(centerLine);

            const halfFieldGeometry = new THREE.PlaneGeometry(FIELD_WIDTH, lineThickness);
            const halfFieldTop = new THREE.Mesh(halfFieldGeometry, lineMaterial);
            halfFieldTop.rotation.x = -Math.PI / 2;
            halfFieldTop.position.set(0, 0.01, FIELD_LENGTH / 2);
            scene.add(halfFieldTop);

            const halfFieldBottom = new THREE.Mesh(halfFieldGeometry, lineMaterial);
            halfFieldBottom.rotation.x = -Math.PI / 2;
            halfFieldBottom.position.set(0, 0.01, -FIELD_LENGTH / 2);
            scene.add(halfFieldBottom);

            const sidelineGeometry = new THREE.PlaneGeometry(lineThickness, FIELD_LENGTH);
            const sidelineLeft = new THREE.Mesh(sidelineGeometry, lineMaterial);
            sidelineLeft.rotation.x = -Math.PI / 2;
            sidelineLeft.position.set(-FIELD_WIDTH / 2, 0.01, 0);
            scene.add(sidelineLeft);
            
            const sidelineRight = new THREE.Mesh(sidelineGeometry, lineMaterial);
            sidelineRight.rotation.x = -Math.PI / 2;
            sidelineRight.position.set(FIELD_WIDTH / 2, 0.01, 0);
            scene.add(sidelineRight);
        }

        function createGoal(xPosition, side) {
            const goalGroup = new THREE.Group();
            goalGroup.position.set(xPosition, 0, 0);

            const goalWidth = 10;
            const goalHeight = 5;
            const goalDepth = 5;
            const postThickness = 0.5;

            const postMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const netMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });

            const leftPost = new THREE.Mesh(new THREE.BoxGeometry(postThickness, goalHeight, postThickness), postMaterial);
            leftPost.position.set(0, goalHeight / 2, goalWidth / 2);
            leftPost.castShadow = true;
            goalGroup.add(leftPost);

            const rightPost = new THREE.Mesh(new THREE.BoxGeometry(postThickness, goalHeight, postThickness), postMaterial);
            rightPost.position.set(0, goalHeight / 2, -goalWidth / 2);
            rightPost.castShadow = true;
            goalGroup.add(rightPost);

            const crossbar = new THREE.Mesh(new THREE.BoxGeometry(postThickness, postThickness, goalWidth), postMaterial);
            crossbar.position.set(0, goalHeight, 0);
            crossbar.castShadow = true;
            goalGroup.add(crossbar);
            
            const net = new THREE.Mesh(new THREE.BoxGeometry(goalDepth, goalHeight, goalWidth + postThickness), netMaterial);
            net.position.set(-goalDepth / 2, goalHeight / 2, 0);
            goalGroup.add(net);

            if (side === 'right') {
                goalGroup.rotation.y = Math.PI;
            }

            scene.add(goalGroup);
        }

        function setupControls() {
            document.getElementById('startButton').addEventListener('click', toggleGame);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        }

        function handleKeyDown(event) {
            if (isGameOver || !isGameStarted || isGoalScored) return;
            const key = event.key.toLowerCase();
            
            if (key === 'l' || key === 'k') {
                if (ballHolder === 'player1') {
                    // On the very first press, just record the time.
                    // Power charging will be handled in the game loop (handleInput).
                    if (!pressedKeys[key]) {
                        p1ShootKeyDownTime = new Date().getTime();
                        shootingPower1 = 0; // Reset power for the new press.
                    }
                } else if (ballHolder === 'player2' && player1.position.distanceTo(player2.position) < TACKLE_DISTANCE) {
                    ballHolder = 'player1';
                    hidePowerMeter(powerMeter2);
                }
            }
            
            if (key === 'f' || key === 'g') {
                if (ballHolder === 'player2') {
                    // On the very first press, just record the time.
                    if (!pressedKeys[key]) {
                        p2ShootKeyDownTime = new Date().getTime();
                        shootingPower2 = 0; // Reset power for the new press.
                    }
                } else if (ballHolder === 'player1' && player2.position.distanceTo(player1.position) < TACKLE_DISTANCE) {
                    ballHolder = 'player2';
                    hidePowerMeter(powerMeter1);
                }
            }

            pressedKeys[key] = true;
        }

        function handleKeyUp(event) {
            if (isGameOver || !isGameStarted || isGoalScored) return;
            const key = event.key.toLowerCase();
            
            if (key === 'l' || key === 'k') {
                if (ballHolder === 'player1') {
                    const pressDuration = new Date().getTime() - p1ShootKeyDownTime;
                    
                    // Check if the key press was a quick tap or a hold.
                    if (pressDuration < TAP_DURATION) {
                        chipShot(player1, lastPlayer1Direction);
                    } else {
                        shootBall(player1, shootingPower1, lastPlayer1Direction);
                    }
                    shootingPower1 = 0;
                    hidePowerMeter(powerMeter1);
                }
            }
            if (key === 'f' || key === 'g') {
                if (ballHolder === 'player2') {
                    const pressDuration = new Date().getTime() - p2ShootKeyDownTime;
                    
                    // Check for tap vs. hold for Player 2.
                    if (pressDuration < TAP_DURATION) {
                        chipShot(player2, lastPlayer2Direction);
                    } else {
                        shootBall(player2, shootingPower2, lastPlayer2Direction);
                    }
                    shootingPower2 = 0;
                    hidePowerMeter(powerMeter2);
                }
            }

            pressedKeys[event.key.toLowerCase()] = false;
        }

        function shootBall(player, power, direction) {
            ballHolder = null;
            
            let shotDirection = new THREE.Vector3();
            if (direction.length() > 0) {
                shotDirection.copy(direction).normalize();
            } else {
                shotDirection.set(0, 0, -1).applyQuaternion(player.quaternion);
            }

            const normalizedPower = power / MAX_POWER;
            const kickStrength = 1 + normalizedPower * 13;
            const kickUpward = normalizedPower * JUMP_STRENGTH;
            
            ball.velocity.copy(shotDirection).multiplyScalar(kickStrength);
            ball.velocity.y = kickUpward;

            const sideForce = new THREE.Vector3();
            const crossVector = new THREE.Vector3().crossVectors(shotDirection, new THREE.Vector3(0, 1, 0));
            sideForce.copy(crossVector).multiplyScalar(normalizedPower * 0.05);
            ball.curveForce = sideForce;
        }

        function chipShot(player, direction) {
            ballHolder = null; // The player no longer has the ball

            let chipDirection = new THREE.Vector3();
            if (direction.length() > 0) {
                chipDirection.copy(direction).normalize();
            } else {
                // If the player is standing still, determine direction based on which player it is
                if (player === player1) {
                    chipDirection.set(-1, 0, 0); // Player 1 (blue) chips towards the left goal
                } else {
                    chipDirection.set(1, 0, 0); // Player 2 (red) chips towards the right goal
                }
            }
            
            // Apply a vertical lift and a small forward push to the ball
            ball.velocity.copy(chipDirection).multiplyScalar(CHIP_FORWARD_STRENGTH);
            ball.velocity.y = CHIP_LIFT_STRENGTH;
        }

        function updatePowerMeter(player, meter, power) {
            meter.style.display = 'block';
            meter.querySelector('.power-meter-fill').style.width = `${(power / MAX_POWER) * 100}%`;

            const playerScreenPosition = player.position.clone();
            playerScreenPosition.project(camera);

            const container = document.querySelector('.game-container');
            const containerRect = container.getBoundingClientRect();

            const x = ((playerScreenPosition.x + 1) / 2) * container.clientWidth;
            const y = ((-playerScreenPosition.y + 1) / 2) * container.clientHeight;

            meter.style.left = `${x}px`;
            meter.style.top = `${y - 20}px`;
        }

        function hidePowerMeter(meter) {
            meter.style.display = 'none';
        }

        function updateScoreDisplay() {
            document.getElementById('score-display').innerHTML = 
                `<span class="blue-score">${blueScore}</span> - <span class="red-score">${redScore}</span>`;
        }

        function handleInput() {
            if (isGoalScored) return;
            
            player1Direction.set(0, 0, 0);
            player2Direction.set(0, 0, 0);
            
            if (pressedKeys['arrowup']) player1Direction.z = -1;
            if (pressedKeys['arrowdown']) player1Direction.z = 1;
            if (pressedKeys['arrowleft']) player1Direction.x = -1;
            if (pressedKeys['arrowright']) player1Direction.x = 1;
            
            if (pressedKeys['w']) player2Direction.z = -1;
            if (pressedKeys['s']) player2Direction.z = 1;
            if (pressedKeys['a']) player2Direction.x = -1;
            if (pressedKeys['d']) player2Direction.x = 1;

            const p1Move = player1Direction.clone().normalize().multiplyScalar(PLAYER_SPEED);
            player1.position.add(p1Move);
            
            const p2Move = player2Direction.clone().normalize().multiplyScalar(PLAYER_SPEED);
            player2.position.add(p2Move);

            // Handle power charging during a hold
            if (pressedKeys['l'] || pressedKeys['k']) {
                if (ballHolder === 'player1') {
                    const pressDuration = new Date().getTime() - p1ShootKeyDownTime;
                    if (pressDuration > TAP_DURATION) {
                        // It's a hold, so charge the shot
                        shootingPower1 = Math.min(shootingPower1 + POWER_CHARGE_RATE, MAX_POWER);
                        updatePowerMeter(player1, powerMeter1, shootingPower1);
                    }
                }
            }
            if (pressedKeys['f'] || pressedKeys['g']) {
                if (ballHolder === 'player2') {
                    const pressDuration = new Date().getTime() - p2ShootKeyDownTime;
                    if (pressDuration > TAP_DURATION) {
                        // It's a hold, so charge the shot
                        shootingPower2 = Math.min(shootingPower2 + POWER_CHARGE_RATE, MAX_POWER);
                        updatePowerMeter(player2, powerMeter2, shootingPower2);
                    }
                }
            }

            if (player1Direction.length() > 0) {
                const angle = Math.atan2(player1Direction.x, player1Direction.z);
                player1.rotation.y = angle;
                lastPlayer1Direction.copy(player1Direction);
            } else if (ballHolder !== 'player1') {
                player1.rotation.y = Math.PI / 2;
                lastPlayer1Direction.set(-1, 0, 0);
            }

            if (player2Direction.length() > 0) {
                const angle = Math.atan2(player2Direction.x, player2Direction.z);
                player2.rotation.y = angle;
                lastPlayer2Direction.copy(player2Direction);
            } else if (ballHolder !== 'player2') {
                player2.rotation.y = -Math.PI / 2;
                lastPlayer2Direction.set(1, 0, 0);
            }
        }

        function updatePhysics() {
            if (isGameOver || !isGameStarted || isGoalScored) return;
            
            const keeperSpeed = 0.2;
            const goalWidth = 10;
            
            if (goalkeeper1.position.z >= goalWidth / 2 - 0.75) goalkeeper1Direction = -1;
            if (goalkeeper1.position.z <= -goalWidth / 2 + 0.75) goalkeeper1Direction = 1;
            goalkeeper1.position.z += goalkeeper1Direction * keeperSpeed;

            if (goalkeeper2.position.z >= goalWidth / 2 - 0.75) goalkeeper2Direction = -1;
            if (goalkeeper2.position.z <= -goalWidth / 2 + 0.75) goalkeeper2Direction = 1;
            goalkeeper2.position.z += goalkeeper2Direction * keeperSpeed;

            ball.velocity.y -= 9.8 * 0.01;

            if (ballHolder) {
                let holderPlayer = ballHolder === 'player1' ? player1 : player2;
                let holderDirection = ballHolder === 'player1' ? player1Direction : player2Direction;
                let lastHolderDirection = ballHolder === 'player1' ? lastPlayer1Direction : lastPlayer2Direction;

                // Use the correct player's direction for dribbling
                const dribbleDirection = holderDirection.length() > 0 ? holderDirection : lastHolderDirection;
                const dribbleOffset = dribbleDirection.clone().normalize().multiplyScalar(DRIBBLING_OFFSET);
                
                // Logic to face the goal when holding the ball and not moving
                if (ballHolder === 'player1' && player1Direction.length() === 0) {
                    player1.rotation.y = -Math.PI / 2;
                }
                if (ballHolder === 'player2' && player2Direction.length() === 0) {
                    player2.rotation.y = Math.PI / 2;
                }

                ball.position.copy(holderPlayer.position).add(dribbleOffset);
                ball.velocity.set(0, 0, 0);
                ball.curveForce = null;
                
                trailVertices.length = 0;
                trailGeometry.setFromPoints([]);

                updatePowerMeter(holderPlayer, holderPlayer === player1 ? powerMeter1 : powerMeter2, holderPlayer === player1 ? shootingPower1 : shootingPower2);
            } else {
                if (ball.curveForce) {
                    ball.velocity.add(ball.curveForce);
                }
                
                ball.velocity.x *= BALL_FRICTION;
                ball.velocity.z *= BALL_FRICTION;
                ball.position.add(ball.velocity);

                if (ball.position.y < 0.75) {
                    ball.position.y = 0.75;
                    ball.velocity.y *= -0.5;
                }

                trailVertices.push(ball.position.clone());
                if (trailVertices.length > 50) {
                    trailVertices.shift();
                }
                trailGeometry.setFromPoints(trailVertices);
            }

            if (!ballHolder) {
                const player1Distance = player1.position.distanceTo(ball.position);
                const player2Distance = player2.position.distanceTo(ball.position);
                const collisionDistance = 1.0 + 0.5;
                if (player1Distance < collisionDistance) {
                    ballHolder = 'player1';
                    hidePowerMeter(powerMeter2);
                } else if (player2Distance < collisionDistance) {
                    ballHolder = 'player2';
                    hidePowerMeter(powerMeter1);
                }
            }
            
            const keeper1CollisionDistance = 1.5 + 0.5;
            if (ball.position.distanceTo(goalkeeper1.position) < keeper1CollisionDistance) {
                ball.velocity.x *= -1.5;
                ball.velocity.z *= -0.5;
                ball.position.x = goalkeeper1.position.x + Math.sign(ball.position.x - goalkeeper1.position.x) * keeper1CollisionDistance;
            }

            const keeper2CollisionDistance = 1.5 + 0.5;
            if (ball.position.distanceTo(goalkeeper2.position) < keeper2CollisionDistance) {
                ball.velocity.x *= -1.5;
                ball.velocity.z *= -0.5;
                ball.position.x = goalkeeper2.position.x + Math.sign(ball.position.x - goalkeeper2.position.x) * keeper2CollisionDistance;
            }
            
            if (Math.abs(ball.position.x) > FIELD_WIDTH / 2 - 0.5) {
                ball.position.x = Math.sign(ball.position.x) * (FIELD_WIDTH / 2 - 0.5);
                ball.velocity.x *= -0.8;
            }
            if (Math.abs(ball.position.z) > FIELD_LENGTH / 2 - 0.5) {
                ball.position.z = Math.sign(ball.position.z) * (FIELD_LENGTH / 2 - 0.5);
                ball.velocity.z *= -0.8;
            }
            
            if (Math.abs(player1.position.x) > FIELD_WIDTH / 2 - 0.75) player1.position.x = Math.sign(player1.position.x) * (FIELD_WIDTH / 2 - 0.75);
            if (Math.abs(player1.position.z) > FIELD_LENGTH / 2 - 0.75) player1.position.z = Math.sign(player1.position.z) * (FIELD_LENGTH / 2 - 0.75);
            
            if (Math.abs(player2.position.x) > FIELD_WIDTH / 2 - 0.75) player2.position.x = Math.sign(player2.position.x) * (FIELD_WIDTH / 2 - 0.75);
            if (Math.abs(player2.position.z) > FIELD_LENGTH / 2 - 0.75) player2.position.z = Math.sign(player2.position.z) * (FIELD_LENGTH / 2 - 0.75);
        }

        function checkScoring() {
            if (isGameOver || !isGameStarted || isGoalScored) return;
            const goalWidth = 10;
            const goalHeight = 5;
            
            const leftGoalLineX = -FIELD_WIDTH / 2 + 1.5;
            if (ball.position.x < leftGoalLineX && ball.position.z > -goalWidth / 2 && ball.position.z < goalWidth / 2 && ball.position.y < goalHeight) {
                const keeperDistance = ball.position.distanceTo(goalkeeper2.position);
                const collisionDistance = 1.5 + 0.5;
                if (keeperDistance < collisionDistance) {
                    ball.velocity.x *= -1.5;
                    ball.position.x = goalkeeper2.position.x + Math.sign(ball.position.x - goalkeeper2.position.x) * collisionDistance;
                    ball.velocity.z *= 0.5;
                    document.getElementById('message').innerHTML = `<span class="red-score">Player 2 Saves!</span>`;
                    setTimeout(() => document.getElementById('message').textContent = "", 1000);
                    return;
                }

                blueScore++;
                document.getElementById('message').innerHTML = `<span class="blue-score">Player 1 Scores!</span>`;
                updateScoreDisplay();
                isGoalScored = true;
                setTimeout(() => {
                    resetBall();
                    isGoalScored = false;
                }, 2000);
            }

            const rightGoalLineX = FIELD_WIDTH / 2 - 1.5;
            if (ball.position.x > rightGoalLineX && ball.position.z > -goalWidth / 2 && ball.position.z < goalWidth / 2 && ball.position.y < goalHeight) {
                const keeperDistance = ball.position.distanceTo(goalkeeper1.position);
                const collisionDistance = 1.5 + 0.5;
                if (keeperDistance < collisionDistance) {
                    ball.velocity.x *= -1.5;
                    ball.position.x = goalkeeper1.position.x + Math.sign(ball.position.x - goalkeeper1.position.x) * collisionDistance;
                    ball.velocity.z *= 0.5;
                    document.getElementById('message').innerHTML = `<span class="blue-score">Player 1 Saves!</span>`;
                    setTimeout(() => document.getElementById('message').textContent = "", 1000);
                    return;
                }

                redScore++;
                document.getElementById('message').innerHTML = `<span class="red-score">Player 2 Scores!</span>`;
                updateScoreDisplay();
                isGoalScored = true;
                setTimeout(() => {
                    resetBall();
                    isGoalScored = false;
                }, 2000);
            }
        }

        function resetBall() {
            pressedKeys = {};

            player1.position.set(FIELD_WIDTH / 4, 0.75, 0);
            player2.position.set(-FIELD_WIDTH / 4, 0.75, 0);
            
            ball.velocity.set(0, 0, 0);
            ball.curveForce = null;
            ballHolder = null;
            
            ball.position.set(0, 0.75, 0);
            
            trailVertices.length = 0;
            trailGeometry.setFromPoints(trailVertices);
            
            document.getElementById('message').textContent = "";
            hidePowerMeter(powerMeter1);
            hidePowerMeter(powerMeter2);
            goalkeeper1.position.z = 0;
            goalkeeper2.position.z = 0;
        }

        function restartGame() {
            blueScore = 0;
            redScore = 0;
            timeRemaining = 90;
            isGameOver = false;
            
            resetBall();
            
            document.getElementById('message').textContent = "Ready to Play!";
            updateScoreDisplay();
            setTimeout(() => {
                document.getElementById('message').textContent = "";
            }, 2000);

            clearInterval(timerInterval);
            isGameStarted = false;
            document.getElementById('startButton').textContent = "Play";
            document.getElementById('timer-display').textContent = 90;
        }

        function toggleGame() {
            if (!isGameStarted) {
                isGameStarted = true;
                document.getElementById('startButton').textContent = "Pause";
                document.getElementById('message').textContent = "";
                startTimer();
            } else {
                isGameStarted = false;
                document.getElementById('startButton').textContent = "Resume";
                clearInterval(timerInterval);
            }
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (timeRemaining > 0) {
                    timeRemaining--;
                    document.getElementById('timer-display').textContent = timeRemaining;
                } else {
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            isGameOver = true;
            clearInterval(timerInterval);
            let message = "";
            if (blueScore > redScore) {
                message = `<span class="blue-score">Player 1 Wins!</span>`;
            } else if (redScore > blueScore) {
                message = `<span class="red-score">Player 2 Wins!</span>`;
            } else {
                message = `It's a draw!`;
            }
            document.getElementById('message').innerHTML = `Game Over!<br>${message}<br>${blueScore} - ${redScore}`;
            document.getElementById('startButton').textContent = "Play Again";
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isGameStarted && !isGameOver) {
                handleInput();
                updatePhysics();
                checkScoring();
            }
            renderer.render(scene, camera);
        }

        function resizeCanvas() {
            const canvas = document.getElementById('game-canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>



